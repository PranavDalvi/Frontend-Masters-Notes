# Load Balancers
- Distributes traffic evenly across services.
- Can act as a gateway for routing
- Handles health checks and fail-overs.

## Reverse Proxy
- Reverse proxy does load balancing like Nginx.
- If very, very high traffic application and we need dedicated load balancer like Amazon Elastic Load Balancer.
- ![](./attachments/Pasted%20image%2020260123195744.png)
## Takeaways
- High-level system design is about focusing on the main components and their interactions.
- Scaling means trade-offs. Vertical scaling is easier but has limits.
- Horizontal scaling increases flexibility but requires more operational overhear.
***
## Questions
1. **What are the key advantages of horizontal scaling (scaling out) compared to vertical scaling?**
	1. Horizontal scaling makes it easier to scale up and down with traffic because the system is designed to be scalable and flexible. It also provides higher availability - if a server goes down, it's better to lose one server out of 100 rather than one out of five. However, it does require orchestration and may require code refactoring to account for APIs being on different machines and changes in latency.
2. **What is the main challenge that arises when scaling from one server to multiple servers, and what technology solves this problem?**
	1. The main challenge is load balancing - the client needs to know which server to connect to, handle DNS updates, and detect when servers are offline. A load balancer solves this problem by managing traffic distribution across multiple servers, making it easy to scale up and down quickly.
3. **What is the difference between a reverse proxy and a load balancer, and which one is more flexible?**
	1. A reverse proxy, such as Nginx, can perform load balancing along with many other functions including HTTPS termination, route-based routing with deeper inspection, and health checks. While dedicated load balancers exist for very high traffic applications (like Amazon Elastic Load Balancer), reverse proxies generally offer more flexibility. In system design discussions, the terms are often used interchangeably unless specific functionality needs to be clarified.
4. **When scaling a simple application from one server to three servers, what unexpected bottleneck might be discovered?**
	1. The database might become the bottleneck if it's not scaled accordingly. When adding more servers, bottlenecks may shift to other downstream resources. What was previously masked by the single server's limitations may now be revealed as the actual performance constraint.
5. **Why do distributed systems typically start with horizontal scaling by default rather than adopting it later?**
	1. Starting with horizontal scaling from the beginning avoids the need to refactor code later. When moving from vertical to horizontal scaling, code must be refactored because APIs that were previously on the same machine may now be on different machines, which changes latency and requires architectural adjustments to handle distributed components.