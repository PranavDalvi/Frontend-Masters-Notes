# Autosave System Design
![](./attachments/Pasted%20image%2020260224115218.png)
## Questions
1. **What is a key downside of using WebSockets compared to server-sent events in a scalable architecture?**
	1. WebSockets are stateful because they maintain a persistent connection, which limits the ability to scale. If you try to scale up or down, you have to migrate all open connections to the new server, which is difficult. Stateful connections make it harder to scale compared to stateless architectures where every request/response is fresh.
2. **In an auto-save feature design, what trade-off is being made when using a cache layer before writing to the database?**
	1. The system is biasing towards availability over consistency. If the service goes down during the interval between caching and database writes, everything in the cache is lost. This means auto-updates could be lost if something happens before the cache is written to the database.
3. **Why might you use a server cache with an auto-update service instead of writing directly to the database for an auto-save feature?**
	1. To reduce database thrashing from unnecessary writes. If auto-saving happens frequently (like every 5 seconds), many writes won't be meaningful as users are still typing and making changes. The cache can hold updates until they stabilize (e.g., 30 seconds of no changes), then the auto-update service writes the final version to the database, reducing unnecessary database operations.
4. **What type of database would be more suitable for an auto-save feature that involves a high volume of writes compared to reads?**
	1. A database optimized for writes, such as Cassandra. Auto-save scenarios generate significantly more writes than reads, so using a write-optimized database for this specific use case would be more efficient than using a traditional database.
5. **What functional requirements should be considered when designing an auto-save feature for a multi-client application?**
	1. Key functional requirements include: how often to save (save interval), strategy to handle conflicts between multiple clients, how to notify clients of changes, and what data to save (entire lists, individual tasks, or diffs). Additional considerations include the read-write ratio changes and whether to use debouncing for input.